//================================================================
//Libraries
//================================================================

#include <stdlib.h>

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>

#include "RGB_setup.h"

//================================================================
//Font
//================================================================
const unsigned char text[] PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //1/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //2/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //3/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //4/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //5/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //6/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //7/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //8/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //9/ --> 	
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //10/ --> 

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //11/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //12/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //13/ --> 

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //14/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //15/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //16/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //17/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //18/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //19/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //20/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //21/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //22/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //23/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //24/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //25/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //26/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //27/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //28/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //29/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //30/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //31/ --> 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //32/ -->  
0x1F,0xBF,0x1F,0x00,0x00,0x00,0x00,0x00, //33/ --> !
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //34/ --> "
0x66,0xFF,0xFF,0x66,0xFF,0xFF,0x66,0x00, //35/ --> #
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //36/ --> $
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //37/ --> %
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //38/ --> &
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //39/ --> '
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //40/ --> (
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //41/ --> )
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //42/ --> *
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //43/ --> +
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //44/ --> ,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //45/ --> -
0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00, //46/ --> .
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //47/ --> /
0x7E,0xC3,0xB1,0x9D,0xC3,0x7E,0x00,0x00, //48/ --> 0
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00, //49/ --> 1
0x00,0xE2,0x91,0x91,0x89,0x89,0x86,0x00, //50/ --> 2
0x00,0xC3,0xDB,0xDB,0xDB,0xDB,0xFF,0x00, //51/ --> 3
0x00,0x1F,0x1F,0x18,0x18,0xFF,0xFF,0x00, //52/ --> 4
0xCF,0xCF,0xC9,0xC9,0xC9,0xF9,0x00,0x00, //53/ --> 5
0x7E,0xDB,0x8B,0x8B,0xDB,0x70,0x00,0x00, //54/ --> 6
0x83,0xC3,0x61,0x31,0x19,0x0D,0x07,0x00, //55/ --> 7
0x00,0xFF,0xFF,0x99,0x99,0xFF,0xFF,0x00, //56/ --> 8
0x0E,0x1B,0x31,0x31,0x1B,0xFF,0xFE,0x00, //57/ --> 9
0x00,0x00,0x66,0x66,0x66,0x00,0x00,0x00, //58/ --> :
0x0C,0x3E,0x7E,0xFC,0xFC,0x7E,0x3E,0x0C, //59/ --> ;
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //60/ --> <
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //61/ --> =
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //62/ --> >
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //63/ --> ?
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //64/ --> @
0xFC,0xFE,0x13,0x13,0x13,0xFE,0xFC,0x00, //65/ --> A
0xFF,0xFF,0x89,0x8F,0xFE,0x70,0x00,0x00, //66/ --> B
0x7E,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0x00, //67/ --> C
0xFF,0xFF,0xC3,0xC3,0xE6,0x7E,0x18,0x00, //68/ --> D
0xFF,0xFF,0xDB,0xDB,0xDB,0xC3,0x00,0x00, //69/ --> E
0xFF,0xFF,0x1B,0x1B,0x03,0x03,0x00,0x00, //70/ --> F
0xFF,0xFF,0xC3,0xC3,0xDB,0xDB,0xFB,0x00, //71/ --> G
0xFF,0xFF,0x18,0x18,0x18,0xFF,0xFF,0x00, //72/ --> H
0x00,0xC3,0xC3,0xFF,0xC3,0xC3,0x00,0x00, //73/ --> I
0xE0,0xE3,0xC3,0xFF,0x7F,0x03,0x03,0x00, //74/ --> J
0x00,0xFF,0xFF,0x1C,0x36,0xE3,0xC1,0x00, //75/ --> K
0x00,0x00,0xFF,0xFF,0xC0,0xC0,0xC0,0x00, //76/ --> L
0xFF,0xFF,0x06,0x0C,0x06,0xFF,0xFF,0x00, //77/ --> M
0xFF,0xFF,0x06,0x1C,0x30,0xFF,0xFF,0x00, //78/ --> N
0x3C,0x7E,0xC3,0xC3,0xC3,0x7E,0x3C,0x00, //79/ --> O
0x00,0xFF,0xFF,0x11,0x11,0x11,0x0E,0x00, //80/ --> P
0x3C,0x7E,0xC3,0xD3,0xE3,0x7E,0x9C,0x00, //81/ --> Q
0xFE,0xFF,0x11,0x31,0x7B,0xCE,0x80,0x00, //82/ --> R
0xDF,0xDF,0xD9,0xD9,0xF9,0xF9,0x00,0x00, //83/ --> S
0x00,0x03,0x03,0xFF,0xFF,0x03,0x03,0x00, //84/ --> T
0xFF,0xFF,0xC0,0xC0,0xC0,0xFF,0xFF,0x00, //85/ --> U
0x07,0x1F,0x78,0xE0,0x78,0x1F,0x07,0x00, //86/ --> V
0x7F,0xFF,0xC0,0x7C,0xC0,0xFF,0x7F,0x00, //87/ --> W
0xC1,0x63,0x36,0x18,0x36,0x63,0xC1,0x00, //88/ --> X
0x83,0xCE,0xFC,0x38,0x0C,0x07,0x03,0x00, //89/ --> Y
0xC3,0xE3,0xF3,0xDB,0xDB,0xCF,0xC7,0x00, //90/ --> Z
};



//================================================================
//Global Variables
//================================================================
static char frame_data[64];	//Frame Data buffer contains 64 Bytes which correspond to the color for each LED on the RGB Matrix. This Frame will be sent over SPI.
static char character_leds[8];	//The Character LED buffer contains the color for one row of LEDs on the RGB Matrix. These values are copied into the Frame Data buffer.

static char text_color=RED, background_color=BLACK;	//These values define what color will be filled in the Frame Data buffer. Colors are defined in Setup.h

//Messages to be displayed on the Matrix
static char message_1[]="WELCOME";
static char message_2[]="TO";
static char message_3[]="POLYTECH LILLE!";

int rgb_main (void)
{	
	char current_message=0;	//Indicates which string we should be displaying
	char change_message=1;	//Flag to notify firmware we've finished displaying the current message and we need to get the next one
	char *message='\0';		//Pointer to the string we want to display

    init_rgb(); //Boot up defaults and configure Bluetooth connection

	while(1){
		//Check to see if we need to get a new message to display
		if(change_message){
			change_message=0;	//Reset the flag
			//Grab the appropriate message
			if(current_message==0)message=&message_1[0];
			if(current_message==1)message=&message_2[0];
			if(current_message==2)message=&message_3[0];
		}
		
		//Each time through this loop, we'll send an image to the RGB backpack. The scroll index will tell put_char() the row index of character start position on the matrix
		//After running through the entirety of this loop, the current message character will have scrolled across the RGB matrix one row at a time, and the
		//next character will currently be on the matrix.
		int scroll_index;
		for(scroll_index=-1; scroll_index >=-8; scroll_index--){
			
			//Put the current character, offset by scroll_index, into the frame_data[] buffer
			putchar_frame(message, scroll_index, text_color);
			
			cbi(PORTB, CS);		//Putting the CS line low will start the communication sequence
			int LED;
			_delay_ms(1);
//#ifdef MATRIX_V24
			spi_exch(0x26);
//#endif
			for(LED=0; LED<64; LED++){	//Send 64 bytes to the RGB serial backpack. One byte is sent for each LED. The format of the byte is RRRGGGBB.
				spi_exch(frame_data[LED]);	//*See ioinit() for SPI Hardware Setup
			}
			_delay_ms(1);
			sbi(PORTB, CS);		//Setting the CS line high will terminate the communication sequence.

			_delay_ms(100);		//Pause before sending the next set of data
		}	

		//If we've reached the end of the current message, it's time to get the next one
		if(*(message+1)=='\0'){
			current_message+=1;
			if(current_message==3)current_message=0;
			change_message=1;
		}
		//If we haven't reached the end of the current message, increment to get the next character
		else message+=1;
	}

    return (0);
}


//Core functions
//==================================================
//Usage:	init_rgb();
//Purpose:	Initialize the AVR I/O, SPI Hardware and UART
//Inputs:	None
//Outputs:	None
void init_rgb(void)
{
    //1 = output, 0 = input
	//Setup the AVR I/O
	DDRB |= (1<<CS)|(1<<MOSI)|(1<<SCK);

    //SPI Bus setup
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);	//Enable SPI HW, Master Mode, divide clock by 
	//NOTE: By Default, CPOL and CPHA are 0. This means you should set up your SPI hardware for
	//      and active high clock; and the SPI bus should sample on the leading (rising) edge and setup data on the trailing (falling) edge.


//	cbi(PORTB, CS);		//Putting the CS line low will start the communication sequence
//	_delay_ms(1);
//	spi_exch('%');
//	spi_exch(1);
//	_delay_ms(1);
//	sbi(PORTB, CS);
}


//Usage:	returned_char=spi_exch(0xA5);
//Purpose:	Sends/Received a character on the SPI bus
//Inputs:	uint8_t output->character to be sent to the SPI bus
//Outputs:	Returns the character that was received on the SPI bus
uint8_t spi_exch(uint8_t output)
{
	SPDR = output;				//Send Output to the SPI Data Register to initialize "Send"
	while(!(SPSR & 1<<SPIF));	//Wait for SPI to finish sending
	return SPDR;				//Return the received byte
}

//Usage:	putchar_frame(current_message, -1, RED);
//Purpose:	Puts data into the Frame Data buffer to be displayed on the RGB matrix. Depending
//			on the position, part of the current character along with part of the next character
//			in the string will be displayed
//Inputs:	char *message->pointer to the current character in the string to be displayed.
//			int position->Position allows you to display the character from a given starting position.
//			(i.e. If you pass the character 'R', and the next character in the string is 'Y', and you 
//			 send position=-4, then the second half of 'R' will be displayed, followed by the first
//			 half of 'Y'.)
//			char color->Color to display the character
//
//Outputs:	None
void putchar_frame(char *message, int position, char color){
	//Loads the character in the Text Array (Located at the top of this file)
	//NOTE: Only capital letters are supported in this sample.
	int text_offset = message[0]*8;
	int text_offset_2=0;
	
	//Check to see if there is a character after the current character.
	if(message[1]!='\n')text_offset_2 = message[1]*8;

	//If a positive position is sent, we should fill (8-position) rows with the background color
	//before starting to fill the matrix with the text data.
	if(position >= 0){
		//Fill the first 'position' rows with the background color
		int row;
		for(row=0; row<position; row++){
			character_leds[row]=background_color;
		}
		//After row 'position' fill the rest of the matrix with the text data
		for(row=position; row<8; row++){
			character_leds[row]=pgm_read_byte(&(text[text_offset+(row-position)]));
		}
	}
	
	//If a negative position is sent, fill in the (position-8) rows with the current character,
	//then fill the remaining rows with the next character.
	else{
		//Fill the first 'position' rows with the second character
		int row;
		for(row=position; row <0; row++){
			if(message[1]!='\n'){
				character_leds[row+8]=pgm_read_byte(&(text[text_offset_2+(row-position)]));
			}
			else character_leds[8+row]=background_color;
		}
		//Fill the rest of the rows with the current character
		for(row=-8; row<position; row++){
			character_leds[8+row]=pgm_read_byte(&(text[text_offset+((row+8)-position)]));
		}
	}

	//Copy the Character LEDs buffer into the Frame Data buffer.
	int row;
	for(row=0; row<8; row++){
		int LED;
		for(LED=0; LED<8; LED++){			
			//Map the Character LEDs to their correct location in the Frame Data buffer
			if(character_leds[row] & (1<<abs(LED-7)))frame_data[LED*8+row]=color;
			else frame_data[LED*8+row]=background_color;
		}
	}

}
